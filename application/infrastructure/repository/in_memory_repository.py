from threading import Lock

from application.exceptions import MemoryIsFullException
from application.ports import InMemoryRepositoryPort
from infrastructure.flags import storing_allowed


class InMemoryRepository(InMemoryRepositoryPort):
    """
    This repo is used to store the shortened links in random access memory.
    """

    def __init__(self) -> None:
        """
        Initialize the repo.

        As everything else in application this limit exists only to demonstrate
        the understanding of race conditions and memory corruption problems.

        Without the lock, or with the different locks (i.e. defined in different threads)
        two (many) threads may attempt to modify the self.links dictionary which would result
        in exceeding the synthetic limit, data incosistency, or in, which is worse, potentially damaging the data
        structure (in case the OS would take control from a thread that is in the process of dictionary modification).
        """
        self.links = {}
        self.limit = 100
        self.count = 0
        self.lock = Lock()

    def store(self, shortened_link_data: dict) -> None:
        """
        Store a shortened link.

        Should the storage capacity be exceeded the storing flag will be downed.

        Args:
            shortened_link_data (dict): A dictionary that contains shortened link and it's full counterpart.

        Raises:
            MemoryIsFullException: Raisen if the limit is already exceeded.
        """
        with self.lock:
            if self.count == self.limit:
                raise MemoryIsFullException(
                    title='Memory Exception.',
                    details={'reason': 'The memory limit was exceeded.'},
                )
            self.links.update({shortened_link_data.get('shortened'): shortened_link_data.get('original')})
            self.count += 1
            if self.count == self.limit:
                storing_allowed.clear()

    def retrieve(self, shortened_link: str) -> str:
        """
        Retrieve a link by it's shortened counterpart.

        Args:
            shotened_link (str): A short link that has been previously generated by this application.

        Returns:
            str: A string that contains full link or an empty string if none was found.
        """
        with self.lock:
            if (full_link := self.links.get(shortened_link)) is not None:
                self.count -= 1
                storing_allowed.set()
                return full_link

in_memory_repository = InMemoryRepository()
